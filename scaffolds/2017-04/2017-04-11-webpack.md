title: webpack
date: 2017-04-11 21:57:13
tags:
  - webpack
---

# 常用配置解析（这里以vue脚手架生成为例）

## 输入(entry)

```
  entry: {
    app: './src/main.js'
  }
```
## 输出(output)
```
output: {
  path: path.resolve(__dirname, './dist'),  // 文件构建完成后的生成目录
  publicPath: '/dist/',	// build.js相对于服务器环境的哪层目录
  filename: 'build.js' // 代码生成的文件名
}
```
## 模块(module)

如何处理项目不同类型的模块

```
module: {
    rules: [
      {
        test: /\.vue$/, // 匹配处理.vue文件
        loader: 'vue-loader', //使用vue-loader处理,`npm install vue-loader`
        options: {	//options是对vue-loader的额外选项配置
          loaders: {
            // 由于sass-loader将SCSS作为默认解析模式，因此将lang属性的“scss”和“sass”值映射到这里的正确配置。
            'scss': 'vue-style-loader!css-loader!sass-loader',
            'sass': 'vue-style-loader!css-loader!sass-loader?indentedSyntax',
          }
        }，
        exclude: /node_modules/	// 排除需要处理的目录（不推荐使用exclude）
      },
      {
        test: /\.js$/,	// 匹配处理.js文件
        loader: 'babel-loader',	//使用babel-loader处理,这个作用就是将es6转化成es5
     		include: [resolve('src'), resolve('test')] // 必须处理包含src和test文件夹
      },
      {
        test: /\.(eot|ttf|woff|woff2|png|jpg|gif|svg)$/,	// 匹配相关图片类型文件
        loader: 'file-loader', // 使用url-loader处理
        query: {  // query是对loader做额外的选项配置
	        limit: 10000, //图片小于10000字节时以base64的方式引用
	        name: utils.assetsPath('img/[name].[hash:7].[ext]') //文件名为name.7位hash值.拓展名
	      }
      },
      {
	      test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, //字体文件
	      loader: 'url-loader', //使用url-loader处理
	      query: {
	        limit: 10000,  //字体文件小于1000字节的时候处理方式
	        name: utils.assetsPath('fonts/[name].[hash:7].[ext]') //文件名为name.7位hash值.拓展名
	      }
	    },
      {
        test: /\.css$/,
        loader: 'style-loader!css-loader'
      }
    ]
  },
```

`注: 关于query 仅由于兼容性原因而存在。请使用 options 代替。`

## 解析(resolve)

```
resolve: {
  modules: [path.resolve(__dirname, 'src'), 'node_modules'],  // 只解析的目录
  extensions: ['.js', '.vue', '.json', '.scss'],  // 解析的文件扩展名
  alias: {  // 设置引入模块的别名
    'vue$': 'vue/dist/vue.esm.js',
    '@': resolve('src'),
    'utils': resolve('src/utils'),
    'assets': resolve('src/assets'),
    'components': resolve('src/components'),
    'flexible': resolve('src/assets/lib/flexible.js')
  }
},
```

## 常用插件(plugins)

webpack插件分为两种，一种是原生插件，就是说不需要安装和引用可直接使用，另一种是第三方插件，需要npm安装，引用后才可使用。

先讲一下常用原生插件

```
plugins: [
  new webpack.DefinePlugin({
    'process.env': {
      NODE_ENV: '"production"'    // 配置全局环境为生产环境
    }
  }),
  
  new webpack.HotModuleReplacementPlugin(), // 热更新插件
  new webpack.NoEmitOnErrorsPlugin(), // 跳过编译时出错的代码并记录，使编译后运行时的包不会发生错误。
  new FriendlyErrorsPlugin()  // 友好错误提示
]

```

### webpack.optimize.UglifyJsPlugin

解析/压缩/美化所有的js

```
new webpack.optimize.UglifyJsPlugin({
  sourceMap: true
  mangle: {
      except: ['$super', '$', 'exports', 'require']
  },
  compressor: { // 压缩配置
    // 在UglifyJs删除没有用到的代码时不输出警告
    warnings: false,
    // 删除所有的 `console` 语句，可以兼容ie浏览器
    drop_console: deployEnv === 'prd',
    // 删除所有的 `debugger`语句
    drop_debugger: true,
    // 内嵌定义了但是只用到一次的变量
    collapse_vars: deployEnv === 'prd',
    // 提取出出现多次但是没有定义成变量去引用的静态值
    reduce_vars: true
  },
})
```

参数说明：

mangle: 通过设置except数组来防止指定变量被改变
sourceMap: 生成SourceMap文件，会导致编译过程变慢，默认true
test/include/exclude: 使用一个或多个正则表达式来过滤要处理的文件
compressor: 压缩配置项

### webpack.optimize.CommonsChunkPlugin

提取代码中的公共模块，然后将公共模块打包到一个独立的文件中，以便在其他的入口和模块中使用。
不要忘记在html中单独引入抽离出来的公共模块。

```
new webpack.optimize.CommonsChunkPlugin({
  name: 'vendor',  // 生成的公共模块的文件名
  minChunks: 3,  // 至少要3个引用的模块才能分离出来
  chunks: ["pageA", "pageB"],  // 只应用这些模块
})
```

在vue-cli生成的项目工程的webpack配置中会new 两次，请看下面说明
```
//分离公共js到vendor中
new webpack.optimize.CommonsChunkPlugin({
  name: 'vendor',  //文件名
  minChunks: functions(module, count) { // 声明公共的模块来自node_modules文件夹
    return (module.resource && /\.js$/.test(module.resource) && module,resource.indexOf(path.join(__dirname, '../node_modules')) === 0)
  }
}),
//上面虽然已经分离了第三方库,每次修改编译都会改变vendor的hash值，导致浏览器缓存失效。原因是vendor包含了webpack在打包过程中会产生一些运行时代码，运行时代码中实际上保存了打包后的文件名。当修改业务代码时,业务代码的js文件的hash值会改变。一旦改变必然会导致vendor变化。vendor变化会导致其hash值变化。
//下面主要是将运行时代码提取到单独的manifest文件中，防止其影响vendor.js
new webpack.optimize.CommonsChunkPlugin({
  name: 'mainifest',
  chunks: ['vendor']
})

```

### webpack.DllReferencePlugin

把常用的库并且不会改变的库进行分离，加速构建的作用

```
new webpack.DllReferencePlugin({
  context: __dirname,  // 作用于哪个环境
  manifest: require(./manifest.json)
})
```

接下来，讲常用第三方插件

### HtmlWebpackPlugin

自动生成html文件的插件

```
 new HtmlWebpackPlugin({
    filename: 'index.html',
    template: 'index.html',
    inject: true
  }),
```

`参数说明：`

* title: 用来生成页面的 title 元素
* filename: 输出的 HTML 文件名，默认是 index.html, 也可以直接配置带有子目录。
* template: 模板文件路径，支持加载器，比如 html!./index.html
* inject: true | 'head' | 'body' | false  ,注入所有的资源到特定的 template 或者 templateContent 中，如果设置为 true 或者 body，所有的 javascript 资源将被放置到 body 元素的底部，'head' 将放置到 head 元素中。
* favicon: 添加特定的 favicon 路径到输出的 HTML 文件中。
* minify: {} | false , 传递 html-minifier 选项给 minify 输出
* hash: true | false, 如果为 true, 将添加一个唯一的 webpack 编译 hash 到所有包含的脚本和 CSS 文件，对于解除 cache 很有用。
* cache: true | false，如果为 true, 这是默认值，仅仅在文件修改之后才会发布文件。
* showErrors: true | false, 如果为 true, 这是默认值，错误信息会写入到 HTML 页面中
* chunks: 允许只添加某些块 (比如，仅仅 unit test 块)
* chunksSortMode: 允许控制块在添加到页面之前的排序方式，支持的值：'none' | 'default' | {function}-default:'auto'|'dependency'
* excludeChunks: 允许跳过某些块，(比如，跳过单元测试的块) 

### ExtractTextPlugin

将js中引入的css分离的插件

```
new ExtractTextPlugin({
  filename: utils.assetsPath('css/[name].[contenthash].css') //分离出的css文件名
  allChunks: true // 分离所有的模块
})
```

### OptimizeCSSPlugin

压缩提取出的css，并解决ExtractTextPlugin分离出的css重复问题(多个文件引入同一css文件)

```
new OptimizeCSSPlugin({
  cssProcessorOptions: {
    safe: true
  }
}),
```

### CopyWebpackPlugin

```
// 复制静态资源,将static文件内的内容复制到指定文件夹
new CopyWebpackPlugin([{
  from: path.resolve(__dirname, '../static'), // 从哪个路径复制
  to: config.build.assetsSubDirectory,  // 复制到的路径
  ignore: ['.*']  //过滤文件
}])
```

